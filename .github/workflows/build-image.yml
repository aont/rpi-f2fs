name: Build Raspberry Pi F2FS image

on:
  workflow_dispatch:
    inputs:
      image_url:
        description: Raspberry Pi OS image URL
        required: false
        default: https://downloads.raspberrypi.com/raspios_arm64/images/raspios_arm64-2025-12-04/2025-12-04-raspios-trixie-arm64.img.xz
      release_tag:
        description: Release tag name (optional). If empty, auto-generate from date/commit/image name.
        required: false
        default: ""

permissions:
  contents: write
  actions: read

defaults:
  run:
    shell: /usr/bin/bash --noprofile --norc -e -o pipefail {0}

jobs:
  build-and-release:
    runs-on: ubuntu-24.04

    env:
      UBUNTU_MINIMAL_IMG_URL: https://cloud-images.ubuntu.com/minimal/releases/noble/release/ubuntu-24.04-minimal-cloudimg-amd64.img
      UBUNTU_MINIMAL_IMG_NAME: ubuntu-24.04-minimal-cloudimg-amd64.img

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Resolve build metadata
        id: meta
        env:
          INPUT_IMAGE_URL: ${{ github.event.inputs.image_url }}
          INPUT_RELEASE_TAG: ${{ github.event.inputs.release_tag }}
        run: |
          set -euo pipefail

          IMAGE_URL="${INPUT_IMAGE_URL:-https://downloads.raspberrypi.com/raspios_arm64/images/raspios_arm64-2025-12-04/2025-12-04-raspios-trixie-arm64.img.xz}"
          IMAGE_XZ_NAME="$(basename "${IMAGE_URL}")"
          IMAGE_NAME="${IMAGE_XZ_NAME%.img.xz}"
          SRC_IMAGE_NAME="${IMAGE_XZ_NAME%.xz}"
          OUT_IMAGE_NAME="${IMAGE_NAME}-f2fs.img"

          if [[ -n "${INPUT_RELEASE_TAG:-}" ]]; then
            RELEASE_TAG="${INPUT_RELEASE_TAG}"
          else
            RELEASE_TAG="$(date -u +%F)-${GITHUB_SHA::7}-${IMAGE_NAME}"
          fi

          {
            echo "image_url=${IMAGE_URL}"
            echo "image_xz_name=${IMAGE_XZ_NAME}"
            echo "image_name=${IMAGE_NAME}"
            echo "src_image_name=${SRC_IMAGE_NAME}"
            echo "out_image_name=${OUT_IMAGE_NAME}"
            echo "release_tag=${RELEASE_TAG}"
          } >> "$GITHUB_OUTPUT"

      - name: Restore cached source image
        id: cache-source-image
        uses: actions/cache@v4
        with:
          path: .cache/${{ steps.meta.outputs.image_xz_name }}
          key: source-image-${{ runner.os }}-${{ steps.meta.outputs.image_name }}

      - name: Download source image
        if: steps.cache-source-image.outputs.cache-hit != 'true'
        env:
          IMAGE_URL: ${{ steps.meta.outputs.image_url }}
          IMAGE_XZ_NAME: ${{ steps.meta.outputs.image_xz_name }}
        run: |
          set -euo pipefail
          mkdir -p .cache
          curl -fL --retry 5 --retry-all-errors --retry-delay 2 \
            "${IMAGE_URL}" \
            -o ".cache/${IMAGE_XZ_NAME}"

      - name: Ensure source archive exists
        env:
          IMAGE_XZ_NAME: ${{ steps.meta.outputs.image_xz_name }}
        run: |
          set -euo pipefail
          test -s ".cache/${IMAGE_XZ_NAME}"

      - name: Unpack source image
        env:
          IMAGE_XZ_NAME: ${{ steps.meta.outputs.image_xz_name }}
        run: |
          set -euo pipefail
          cp ".cache/${IMAGE_XZ_NAME}" .
          xz -T0 -dk "${IMAGE_XZ_NAME}"

      - name: Install deps (qemu/kvm + cloud-init + ssh tooling)
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            util-linux \
            qemu-system-x86 qemu-utils qemu-kvm \
            cloud-image-utils genisoimage \
            openssh-client netcat-openbsd curl

          command -v sg
          qemu-system-x86_64 --version

      - name: Ensure KVM access via kvm group + sg
        run: |
          test -e /dev/kvm
          ls -l /dev/kvm
          id

          sudo usermod -aG kvm "$USER" || true
          sg kvm -c 'id && ls -l /dev/kvm'

      - name: Prepare VM workspace
        run: |
          mkdir -p vm/cache

      - name: Restore cached Ubuntu minimal image
        id: cache-ubuntu-img
        uses: actions/cache@v4
        with:
          path: vm/cache/${{ env.UBUNTU_MINIMAL_IMG_NAME }}
          key: ubuntu-minimal-${{ runner.os }}-${{ env.UBUNTU_MINIMAL_IMG_NAME }}

      - name: Download Ubuntu Minimal Cloud Image (only if cache miss)
        if: steps.cache-ubuntu-img.outputs.cache-hit != 'true'
        run: |
          curl -fsSL -o "vm/cache/${UBUNTU_MINIMAL_IMG_NAME}" "${UBUNTU_MINIMAL_IMG_URL}"
          ls -lh "vm/cache/${UBUNTU_MINIMAL_IMG_NAME}"

      - name: Prepare cloud-init seed + overlay disk
        run: |
          cd vm

          ssh-keygen -t ed25519 -N "" -f id_ed25519 <<<y >/dev/null 2>&1

          cat > user-data <<'EOF'
          #cloud-config
          users:
            - name: ubuntu
              sudo: ["ALL=(ALL) NOPASSWD:ALL"]
              groups: [sudo]
              shell: /bin/bash
              ssh_authorized_keys:
                - __SSH_PUBKEY__
          ssh_pwauth: false
          disable_root: true
          package_update: false
          packages: []
          runcmd:
            - [ sh, -c, "echo cloud-init-ready > /var/tmp/cloud-init-ready" ]
          EOF

          PUBKEY="$(cat id_ed25519.pub)"
          sed -i "s|__SSH_PUBKEY__|${PUBKEY}|g" user-data

          cat > meta-data <<'EOF'
          instance-id: gh-actions-qemu
          local-hostname: gh-actions-qemu
          EOF

          cloud-localds -v seed.iso user-data meta-data

          BASE_IMG="cache/${UBUNTU_MINIMAL_IMG_NAME}"
          test -f "${BASE_IMG}"
          qemu-img create -f qcow2 -F qcow2 -b "${BASE_IMG}" ubuntu-minimal.qcow2 20G

      - name: Boot VM with KVM (SSH forwarded to localhost:2222)
        run: |
          cd vm

          (ss -ltnp | grep ':2222' && echo "port 2222 already in use" && exit 1) || true

          : > qemu.log

          sg kvm -c 'exec /usr/bin/bash -lc "
            set -euo pipefail

            nohup qemu-system-x86_64 \
              -machine accel=kvm \
              -cpu host \
              -smp 2 \
              -m 4096 \
              -nographic \
              -drive file=ubuntu-minimal.qcow2,format=qcow2,if=virtio \
              -drive file=seed.iso,media=cdrom \
              -netdev user,id=net0,hostfwd=tcp::2222-:22 \
              -device virtio-net-pci,netdev=net0 \
              >> qemu.log 2>&1 &

            echo \$! > qemu.pid
            test -s qemu.pid
          "'

          sleep 2
          PID="$(cat qemu.pid)"

          if ! ps -p "$PID" >/dev/null 2>&1; then
            echo "QEMU exited immediately. Dumping qemu.log:"
            echo "----------------------------------------"
            tail -n 200 qemu.log || true
            echo "----------------------------------------"
            exit 1
          fi

          ps -p "$PID" -o pid,cmd

      - name: Wait for SSH to become ready
        run: |
          cd vm

          for i in {1..120}; do
            if nc -z 127.0.0.1 2222; then
              echo "SSH port is open."
              break
            fi
            sleep 2
          done

          SSH_OPTS="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=5"
          for i in {1..120}; do
            if ssh ${SSH_OPTS} -i id_ed25519 -p 2222 ubuntu@127.0.0.1 "test -f /var/tmp/cloud-init-ready"; then
              echo "cloud-init is ready."
              break
            fi
            sleep 2
          done

      - name: Build F2FS image inside VM
        env:
          SRC_IMAGE_NAME: ${{ steps.meta.outputs.src_image_name }}
          OUT_IMAGE_NAME: ${{ steps.meta.outputs.out_image_name }}
        run: |
          SSH_OPTS="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"

          ssh ${SSH_OPTS} -i vm/id_ed25519 -p 2222 ubuntu@127.0.0.1 '
            set -euo pipefail
            KREL="$(uname -r)"
            sudo apt-get update
            sudo apt-get install -y "linux-modules-extra-${KREL}"
            sudo modprobe f2fs
            grep -w f2fs /proc/filesystems
          '

          ssh ${SSH_OPTS} -i vm/id_ed25519 -p 2222 ubuntu@127.0.0.1 "mkdir -p ~/work"
          scp ${SSH_OPTS} -i vm/id_ed25519 -P 2222 ./rpi-f2fs.bash "ubuntu@127.0.0.1:~/work/rpi-f2fs.bash"
          scp ${SSH_OPTS} -i vm/id_ed25519 -P 2222 "./${SRC_IMAGE_NAME}" "ubuntu@127.0.0.1:~/work/${SRC_IMAGE_NAME}"

          ssh ${SSH_OPTS} -i vm/id_ed25519 -p 2222 ubuntu@127.0.0.1 \
            "chmod +x ~/work/rpi-f2fs.bash && sudo bash ~/work/rpi-f2fs.bash ~/work/${SRC_IMAGE_NAME} ~/work/${OUT_IMAGE_NAME}"

          scp ${SSH_OPTS} -i vm/id_ed25519 -P 2222 "ubuntu@127.0.0.1:~/work/${OUT_IMAGE_NAME}" "./${OUT_IMAGE_NAME}"

      - name: Cleanup (stop QEMU)
        if: always()
        run: |
          if [ -f vm/qemu.pid ]; then
            PID="$(cat vm/qemu.pid || true)"
            if [ -n "${PID}" ] && ps -p "${PID}" >/dev/null 2>&1; then
              kill "${PID}" || true
              sleep 2
              ps -p "${PID}" >/dev/null 2>&1 && kill -9 "${PID}" || true
            fi
          fi

      - name: Upload qemu.log (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: qemu-log
          path: vm/qemu.log

      - name: Compress output image
        env:
          OUT_IMAGE_NAME: ${{ steps.meta.outputs.out_image_name }}
        run: |
          set -euo pipefail
          xz -T0 -z -9e "${OUT_IMAGE_NAME}"

      - name: Create release if needed
        env:
          GH_TOKEN: ${{ github.token }}
          RELEASE_TAG: ${{ steps.meta.outputs.release_tag }}
        run: |
          set -euo pipefail
          if gh release view "${RELEASE_TAG}" >/dev/null 2>&1; then
            echo "Release ${RELEASE_TAG} already exists"
          else
            gh release create "${RELEASE_TAG}" --title "${RELEASE_TAG}" --generate-notes
          fi

      - name: Upload image to release
        env:
          GH_TOKEN: ${{ github.token }}
          RELEASE_TAG: ${{ steps.meta.outputs.release_tag }}
          OUT_IMAGE_NAME: ${{ steps.meta.outputs.out_image_name }}
        run: |
          set -euo pipefail
          gh release upload "${RELEASE_TAG}" "${OUT_IMAGE_NAME}.xz" --clobber
