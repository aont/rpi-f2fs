name: Build Raspberry Pi F2FS image

on:
  workflow_dispatch:
    inputs:
      image_url:
        description: Raspberry Pi OS image URL
        required: false
        default: https://downloads.raspberrypi.com/raspios_lite_arm64/images/raspios_lite_arm64-2025-12-04/2025-12-04-raspios-trixie-arm64-lite.img.xz
      release_tag:
        description: Release tag name (optional). If empty, auto-generate from commit date (YYYYMMDD)/commit id.
        required: false
        default: ""

permissions:
  contents: write
  actions: read

defaults:
  run:
    shell: /usr/bin/bash --noprofile --norc -e -o pipefail {0}

jobs:
  build-and-release:
    runs-on: ubuntu-24.04

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Resolve build metadata
        id: meta
        env:
          INPUT_IMAGE_URL: ${{ github.event.inputs.image_url }}
          INPUT_RELEASE_TAG: ${{ github.event.inputs.release_tag }}
        run: |
          set -euo pipefail

          IMAGE_URL="${INPUT_IMAGE_URL:-https://downloads.raspberrypi.com/raspios_arm64/images/raspios_arm64-2025-12-04/2025-12-04-raspios-trixie-arm64.img.xz}"
          IMAGE_XZ_NAME="$(basename "${IMAGE_URL}")"
          IMAGE_NAME="${IMAGE_XZ_NAME%.img.xz}"
          SRC_IMAGE_NAME="${IMAGE_XZ_NAME%.xz}"
          OUT_IMAGE_NAME="${IMAGE_NAME}-f2fs.img"

          if [[ -n "${INPUT_RELEASE_TAG:-}" ]]; then
            RELEASE_TAG="${INPUT_RELEASE_TAG}"
          else
            RELEASE_TAG="$(git show -s --date=format:%Y%m%d --format=%cd HEAD)-${GITHUB_SHA::7}"
          fi

          {
            echo "image_url=${IMAGE_URL}"
            echo "image_xz_name=${IMAGE_XZ_NAME}"
            echo "image_name=${IMAGE_NAME}"
            echo "src_image_name=${SRC_IMAGE_NAME}"
            echo "out_image_name=${OUT_IMAGE_NAME}"
            echo "release_tag=${RELEASE_TAG}"
          } >> "$GITHUB_OUTPUT"

      - name: Restore cached source image
        id: cache-source-image
        uses: actions/cache@v4
        with:
          path: .cache/${{ steps.meta.outputs.image_xz_name }}
          key: source-image-${{ runner.os }}-${{ steps.meta.outputs.image_name }}

      - name: Download source image
        if: steps.cache-source-image.outputs.cache-hit != 'true'
        env:
          IMAGE_URL: ${{ steps.meta.outputs.image_url }}
          IMAGE_XZ_NAME: ${{ steps.meta.outputs.image_xz_name }}
        run: |
          set -euo pipefail
          mkdir -p .cache
          curl -fL --retry 5 --retry-all-errors --retry-delay 2 \
            "${IMAGE_URL}" \
            -o ".cache/${IMAGE_XZ_NAME}"

      - name: Ensure source archive exists
        env:
          IMAGE_XZ_NAME: ${{ steps.meta.outputs.image_xz_name }}
        run: |
          set -euo pipefail
          test -s ".cache/${IMAGE_XZ_NAME}"

      - name: Unpack source image
        env:
          IMAGE_XZ_NAME: ${{ steps.meta.outputs.image_xz_name }}
        run: |
          set -euo pipefail
          cp ".cache/${IMAGE_XZ_NAME}" .
          xz -T0 -dk "${IMAGE_XZ_NAME}"

      - name: Install deps and enable f2fs on runner
        run: |
          set -euo pipefail
          KREL="$(uname -r)"

          sudo apt-get update
          sudo apt-get install -y \
            util-linux \
            rsync \
            curl \
            "linux-modules-extra-${KREL}"

          sudo modprobe f2fs
          grep -w f2fs /proc/filesystems

      - name: Build F2FS image on runner
        env:
          SRC_IMAGE_NAME: ${{ steps.meta.outputs.src_image_name }}
          OUT_IMAGE_NAME: ${{ steps.meta.outputs.out_image_name }}
          RSYNC_INFO: stats2
        run: |
          set -euo pipefail
          chmod +x ./rpi-f2fs.bash
          sudo RSYNC_INFO=${RSYNC_INFO} bash ./rpi-f2fs.bash "./${SRC_IMAGE_NAME}" "./${OUT_IMAGE_NAME}"

      - name: Compress output image
        env:
          OUT_IMAGE_NAME: ${{ steps.meta.outputs.out_image_name }}
        run: |
          set -euo pipefail
          MEM_AVAILABLE_KIB="$(awk '/MemAvailable:/ {print $2}' /proc/meminfo)"
          RESERVE_KIB=$((1024 * 1024)) # Keep 1 GiB for other processes.

          if (( MEM_AVAILABLE_KIB > RESERVE_KIB )); then
            XZ_MEM_LIMIT_KIB=$((MEM_AVAILABLE_KIB - RESERVE_KIB))
          else
            XZ_MEM_LIMIT_KIB=$((MEM_AVAILABLE_KIB * 80 / 100))
          fi

          # xz requires a meaningful positive memory limit.
          if (( XZ_MEM_LIMIT_KIB < 262144 )); then
            XZ_MEM_LIMIT_KIB=262144
          fi

          echo "MemAvailable: ${MEM_AVAILABLE_KIB} KiB"
          echo "xz --memlimit-compress: ${XZ_MEM_LIMIT_KIB} KiB"

          xz -T0 --memlimit-compress="${XZ_MEM_LIMIT_KIB}KiB" -z -9e "${OUT_IMAGE_NAME}"

      - name: Create release if needed
        env:
          GH_TOKEN: ${{ github.token }}
          RELEASE_TAG: ${{ steps.meta.outputs.release_tag }}
        run: |
          set -euo pipefail
          if gh release view "${RELEASE_TAG}" >/dev/null 2>&1; then
            echo "Release ${RELEASE_TAG} already exists"
          else
            gh release create "${RELEASE_TAG}" --title "${RELEASE_TAG}" --generate-notes
          fi

      - name: Upload image to release
        env:
          GH_TOKEN: ${{ github.token }}
          RELEASE_TAG: ${{ steps.meta.outputs.release_tag }}
          OUT_IMAGE_NAME: ${{ steps.meta.outputs.out_image_name }}
        run: |
          set -euo pipefail
          gh release upload "${RELEASE_TAG}" "${OUT_IMAGE_NAME}.xz" --clobber
